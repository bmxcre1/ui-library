local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

Library = {}

function Library:CreateWindow(title, initialSize)
    local window = {}
    window.Tabs = {}
    window.ActiveTab = nil
    window.Dragging = false
    window.DragStart = Vector2.new(0, 0)
    window.StartPos = Vector2.new(0, 0)
    window.Opened = true
    window.TitleWidth = 0
    window.Destroyed = false
    
    local mainSize = initialSize or Vector2.new(550, 400)
    local mainPos = Vector2.new(100, 100)
    local cornerRadius = 6
    local colors = {
        Background = Color3.fromRGB(15, 15, 15),
        TopBar = Color3.fromRGB(25, 25, 25),
        Accent = Color3.fromRGB(65, 120, 255),
        Text = Color3.fromRGB(230, 230, 230),
        ElementBg = Color3.fromRGB(35, 35, 35),
        Border = Color3.fromRGB(10, 10, 10)
    }

    local function createRoundedBox(radius, filled)
        local shapes = {}
        shapes.TL = Drawing.new("Circle")
        shapes.TR = Drawing.new("Circle")
        shapes.BL = Drawing.new("Circle")
        shapes.BR = Drawing.new("Circle")
        shapes.R1 = Drawing.new("Square")
        shapes.R2 = Drawing.new("Square")
        for _, s in pairs(shapes) do
            if s.Type == "Circle" then
                s.Radius = radius
                s.Filled = filled
                s.NumSides = 20
            else
                s.Filled = filled
            end
            s.Visible = false
        end
        return shapes
    end

    local function createRoundedTop(radius, filled)
        local shapes = {}
        shapes.TL = Drawing.new("Circle")
        shapes.TR = Drawing.new("Circle")
        shapes.Main = Drawing.new("Square")
        shapes.Bottom = Drawing.new("Square")
        for _, s in pairs(shapes) do
            if s.Type == "Circle" then
                s.Radius = radius
                s.Filled = filled
                s.NumSides = 20
            else
                s.Filled = filled
            end
            s.Visible = false
        end
        return shapes
    end

    local mainShapes = createRoundedBox(cornerRadius, true)
    local topBarShapes = createRoundedTop(cornerRadius, true)
    
    local function setShapesColor(shapes, color)
        for _, s in pairs(shapes) do s.Color = color end
    end
    
    setShapesColor(mainShapes, colors.Background)
    setShapesColor(topBarShapes, colors.TopBar)

    local titleText = Drawing.new("Text")
    titleText.Text = title:upper()
    titleText.Size = 18
    titleText.Color = colors.Text
    titleText.Visible = true
    titleText.Font = Drawing.Fonts.System
    titleText.Center = false

    local separator = Drawing.new("Line")
    separator.Thickness = 1
    separator.Color = Color3.new(1, 1, 1)
    separator.Transparency = 0.5
    separator.Visible = true
    
    local wasMousePressed = false

    local function isMouseOver(pos, size)
        local mX, mY = Mouse.X, Mouse.Y
        return mX >= pos.X and mX <= pos.X + size.X and mY >= pos.Y and mY <= pos.Y + size.Y
    end

    local function updateRoundedBox(shapes, pos, size, radius)
        local x, y = pos.X, pos.Y
        local w, h = size.X, size.Y
        local r = radius
        shapes.TL.Position = Vector2.new(x + r, y + r)
        shapes.TR.Position = Vector2.new(x + w - r, y + r)
        shapes.BL.Position = Vector2.new(x + r, y + h - r)
        shapes.BR.Position = Vector2.new(x + w - r, y + h - r)
        shapes.R1.Position = Vector2.new(x + r, y)
        shapes.R1.Size = Vector2.new(w - 2 * r, h)
        shapes.R2.Position = Vector2.new(x, y + r)
        shapes.R2.Size = Vector2.new(w, h - 2 * r)
    end

    local function updatePositions()
        local r = cornerRadius
        local x, y = mainPos.X, mainPos.Y
        local w, h = mainSize.X, mainSize.Y
        updateRoundedBox(mainShapes, mainPos, mainSize, r)
        local th = 40
        topBarShapes.TL.Position = Vector2.new(x + r, y + r)
        topBarShapes.TR.Position = Vector2.new(x + w - r, y + r)
        topBarShapes.Main.Position = Vector2.new(x + r, y)
        topBarShapes.Main.Size = Vector2.new(w - 2 * r, th)
        topBarShapes.Bottom.Position = Vector2.new(x, y + r)
        topBarShapes.Bottom.Size = Vector2.new(w, th - r)
        titleText.Position = mainPos + Vector2.new(15, 12)
        window.TitleWidth = math.clamp(titleText.TextBounds.X, 100, 300)
        local sepX = 15 + window.TitleWidth + 10
        local sepY = mainPos.Y + 10
        separator.From = Vector2.new(mainPos.X + sepX, sepY)
        separator.To = Vector2.new(mainPos.X + sepX, sepY + 20)
        local tabX = 15 + window.TitleWidth + 22
        for _, tab in ipairs(window.Tabs) do
            tab.Btn.Position = mainPos + Vector2.new(tabX, 12)
            tabX = tabX + tab.Width + 25
            if tab == window.ActiveTab then
                tab.Btn.Color = colors.Accent
                local currentY = mainPos.Y + 60
                for _, elem in ipairs(tab.Elements) do
                    elem:Update(Vector2.new(mainPos.X + 20, currentY))
                    currentY = currentY + elem.Height + 5
                end
            else
                tab.Btn.Color = Color3.fromRGB(150, 150, 150)
            end
        end
    end

    function window:CreateTab(name)
        local tab = {Name = name, Elements = {}, Visible = false, Width = 0}
        local tabBtn = Drawing.new("Text")
        tabBtn.Text = name
        tabBtn.Size = 16
        tabBtn.Color = Color3.fromRGB(150, 150, 150)
        tabBtn.Font = Drawing.Fonts.System
        tabBtn.Visible = true
        tab.Btn = tabBtn
        tab.Width = tabBtn.TextBounds.X
        if tab.Width == 0 then tab.Width = 50 end

        function tab:CreateSection(text)
            local sec = { Type = "Section", Height = 25 }
            local secTxt = Drawing.new("Text")
            secTxt.Text = text
            secTxt.Size = 14
            secTxt.Color = colors.Accent
            secTxt.Font = Drawing.Fonts.System
            secTxt.Visible = false
            sec.Txt = secTxt
            local secLine = Drawing.new("Square")
            secLine.Size = Vector2.new(mainSize.X - 40, 1)
            secLine.Color = colors.ElementBg
            secLine.Filled = true
            secLine.Visible = false
            sec.Line = secLine
            function sec:Update(pos)
                secTxt.Position = pos + Vector2.new(2, 0)
                secLine.Position = pos + Vector2.new(0, 18)
            end
            function sec:SetVisible(vis)
                secTxt.Visible, secLine.Visible = vis, vis
            end
            table.insert(tab.Elements, sec)
            return sec
        end

        function tab:CreateButton(text, callback)
            local btn = { Type = "Button", Height = 32, Callback = callback, ClickTime = 0 }
            local btnRadius = 5
            btn.BorderShapes = createRoundedBox(btnRadius, true)
            setShapesColor(btn.BorderShapes, colors.Border)
            btn.BgShapes = createRoundedBox(btnRadius, true)
            setShapesColor(btn.BgShapes, colors.ElementBg)
            local btnTxt = Drawing.new("Text")
            btnTxt.Text, btnTxt.Size, btnTxt.Color, btnTxt.Font, btnTxt.Visible, btnTxt.Center = text, 13, colors.Text, Drawing.Fonts.System, false, true
            btn.Txt = btnTxt
            btn.Border = { Position = Vector2.new(0,0), Size = Vector2.new(0,0) }
            function btn:Update(pos)
                local bSize = Vector2.new(mainSize.X - 40, 28)
                btn.Border.Position = pos
                btn.Border.Size = bSize
                updateRoundedBox(btn.BorderShapes, pos, bSize, btnRadius)
                updateRoundedBox(btn.BgShapes, pos + Vector2.new(1, 1), Vector2.new(mainSize.X - 42, 26), btnRadius)
                btnTxt.Position = pos + Vector2.new((mainSize.X - 40)/2, 13)
                if os.clock() - btn.ClickTime > 0.1 then setShapesColor(btn.BgShapes, colors.ElementBg) end
            end
            function btn:SetVisible(vis)
                for _, s in pairs(btn.BorderShapes) do s.Visible = vis end
                for _, s in pairs(btn.BgShapes) do s.Visible = vis end
                btnTxt.Visible = vis
            end
            function btn:SetText(newText) btnTxt.Text = newText end
            table.insert(tab.Elements, btn)
            return btn
        end

        function tab:CreateToggle(text, callback)
            local tog = { Type = "Toggle", Height = 25, Callback = callback, State = false }
            local togOuter = Drawing.new("Circle")
            togOuter.Radius, togOuter.Filled, togOuter.Color, togOuter.NumSides, togOuter.Visible = 9, true, colors.Accent, 20, false
            tog.Outer = togOuter
            local togHole = Drawing.new("Circle")
            togHole.Radius, togHole.Filled, togHole.Color, togHole.NumSides, togHole.Visible = 7, true, colors.ElementBg, 20, false
            tog.Hole = togHole
            local togInner = Drawing.new("Circle")
            togInner.Radius, togInner.Filled, togInner.Color, togInner.NumSides, togInner.Visible = 4, true, colors.Accent, 20, false
            tog.Inner = togInner
            local togTxt = Drawing.new("Text")
            togTxt.Text, togTxt.Size, togTxt.Color, togTxt.Font, togTxt.Visible = text, 14, colors.Text, Drawing.Fonts.System, false
            tog.Txt = togTxt
            function tog:Update(pos)
                local circleCenter = pos + Vector2.new(10, 12)
                togOuter.Position, togHole.Position, togInner.Position = circleCenter, circleCenter, circleCenter
                togTxt.Position = pos + Vector2.new(28, 4)
                togInner.Visible = (tog.State and window.Opened and window.ActiveTab == tab)
            end
            function tog:SetVisible(vis)
                togOuter.Visible, togHole.Visible, togTxt.Visible = vis, vis, vis
                togInner.Visible = (vis and tog.State)
            end
            table.insert(tab.Elements, tog)
            return tog
        end

        function tab:CreateSlider(text, min, max, callback)
            local sld = { Type = "Slider", Height = 40, Callback = callback, Min = min, Max = max, Value = min }
            local sBg = Drawing.new("Square")
            sBg.Size, sBg.Filled, sBg.Color, sBg.Visible = Vector2.new(mainSize.X - 40, 4), true, colors.ElementBg, false
            sld.Bg = sBg
            local sFill = Drawing.new("Square")
            sFill.Filled, sFill.Color, sFill.Visible = true, colors.Accent, false
            sld.Fill = sFill
            local sKnob = Drawing.new("Circle")
            sKnob.Radius, sKnob.Filled, sKnob.Color, sKnob.Visible = 6, true, colors.Text, false
            sld.Knob = sKnob
            local sTxt = Drawing.new("Text")
            sTxt.Text, sTxt.Size, sTxt.Color, sTxt.Font, sTxt.Visible = text, 14, colors.Text, Drawing.Fonts.System, false
            sld.Txt = sTxt
            local sVal = Drawing.new("Text")
            sVal.Text, sVal.Size, sVal.Color, sVal.Font, sVal.Visible, sVal.Center = tostring(min), 14, colors.Text, Drawing.Fonts.System, false, true
            sld.Val = sVal
            function sld:Update(pos)
                sTxt.Position = pos
                sVal.Position = pos + Vector2.new(mainSize.X - 50, 0)
                sBg.Position, sFill.Position = pos + Vector2.new(0, 20), pos + Vector2.new(0, 20)
                local pct = (sld.Value - sld.Min) / (sld.Max - sld.Min)
                sFill.Size = Vector2.new(sBg.Size.X * pct, 4)
                sKnob.Position = sFill.Position + Vector2.new(sFill.Size.X, 2)
            end
            function sld:SetVisible(vis)
                sBg.Visible, sFill.Visible, sTxt.Visible, sVal.Visible, sKnob.Visible = vis, vis, vis, vis, vis
            end
            table.insert(tab.Elements, sld)
            return sld
        end

        function tab:CreateDropdown(text, options, callback, multi)
            local drop = {Type = "Dropdown", Height = 40, Callback = callback, Options = options, Open = false, Selected = multi and {} or (options[1] or ""), Multi = multi or false, ScrollIndex = 1, MaxVisible = 6}
            local dropRadius = 5
            drop.BgShapes = createRoundedBox(dropRadius, true)
            setShapesColor(drop.BgShapes, colors.ElementBg)
            drop.Bg = {Position = Vector2.new(0, 0), Size = Vector2.new(mainSize.X - 40, 36)}
            local dTxt = Drawing.new("Text")
            dTxt.Size, dTxt.Color, dTxt.Font, dTxt.Visible = 14, colors.Text, Drawing.Fonts.System, false
            drop.Txt = dTxt
            local dArrow = Drawing.new("Triangle")
            dArrow.Color, dArrow.Filled, dArrow.Visible = colors.Text, true, false
            drop.Arrow = dArrow
            local sUp = Drawing.new("Triangle")
            sUp.Color, sUp.Filled, sUp.ZIndex, sUp.Visible = colors.Text, true, 3, false
            drop.ScrollUp = sUp
            local sDown = Drawing.new("Triangle")
            sDown.Color, sDown.Filled, sDown.ZIndex, sDown.Visible = colors.Text, true, 3, false
            drop.ScrollDown = sDown
            local dListBg = Drawing.new("Square")
            dListBg.Filled, dListBg.Color, dListBg.ZIndex, dListBg.Visible = true, Color3.fromRGB(28, 28, 28), 2, false
            drop.ListBg = dListBg
            drop.OptionDrawings = {}
            function drop:Update(pos)
                drop.Bg.Position = pos
                updateRoundedBox(drop.BgShapes, pos, Vector2.new(mainSize.X - 40, 36), dropRadius)
                dTxt.Position = pos + Vector2.new(10, 11)
                local displayStr = ""
                if drop.Multi then
                    local count = 0
                    local first = nil
                    for k, v in pairs(drop.Selected) do if v then count = count + 1 if not first then first = k end end end
                    displayStr = count == 0 and "None" or (count == 1 and first or count .. " Selected")
                else displayStr = drop.Selected end
                dTxt.Text = text .. ": " .. displayStr
                local arrowCenter = pos + Vector2.new(mainSize.X - 60, 18)
                if drop.Open then
                    dArrow.PointA, dArrow.PointB, dArrow.PointC = arrowCenter + Vector2.new(-5, 3), arrowCenter + Vector2.new(5, 3), arrowCenter + Vector2.new(0, -3)
                else
                    dArrow.PointA, dArrow.PointB, dArrow.PointC = arrowCenter + Vector2.new(-5, -3), arrowCenter + Vector2.new(5, -3), arrowCenter + Vector2.new(0, 3)
                end
                if drop.Open then
                    local curY = pos.Y + 40
                    local cX = pos.X + (mainSize.X - 40) / 2
                    if drop.ScrollIndex > 1 then
                        drop.ScrollUp.Visible = true
                        drop.ScrollUp.PointA, drop.ScrollUp.PointB, drop.ScrollUp.PointC = Vector2.new(cX, curY + 5), Vector2.new(cX - 6, curY + 15), Vector2.new(cX + 6, curY + 15)
                        curY = curY + 20
                    else drop.ScrollUp.Visible = false end
                    local drawn = 0
                    for i = 0, drop.MaxVisible - 1 do
                        local idx = drop.ScrollIndex + i
                        if idx > #drop.Options then break end
                        drawn = drawn + 1
                        if not drop.OptionDrawings[drawn] then
                            local b, t = Drawing.new("Square"), Drawing.new("Text")
                            b.Color, b.Filled, b.ZIndex, b.Visible = Color3.fromRGB(28, 28, 28), true, 2, false
                            t.Color, t.Size, t.Font, t.Center, t.ZIndex, t.Visible = colors.Text, 13, Drawing.Fonts.System, true, 3, false
                            drop.OptionDrawings[drawn] = {Bg = b, Txt = t}
                        end
                        local d = drop.OptionDrawings[drawn]
                        d.Bg.Visible, d.Bg.Position, d.Bg.Size = true, Vector2.new(pos.X, curY), Vector2.new(mainSize.X - 40, 24)
                        d.Txt.Visible, d.Txt.Position, d.Txt.Text = true, Vector2.new(pos.X + (mainSize.X - 40)/2, curY + 12), drop.Options[idx]
                        d.Txt.Color = (drop.Multi and drop.Selected[drop.Options[idx]] or drop.Options[idx] == drop.Selected) and colors.Accent or colors.Text
                        curY = curY + 26
                    end
                    for i = drawn + 1, #drop.OptionDrawings do drop.OptionDrawings[i].Bg.Visible, drop.OptionDrawings[i].Txt.Visible = false, false end
                    if drop.ScrollIndex + drop.MaxVisible <= #drop.Options then
                        drop.ScrollDown.Visible = true
                        drop.ScrollDown.PointA, drop.ScrollDown.PointB, drop.ScrollDown.PointC = Vector2.new(cX, curY + 15), Vector2.new(cX - 6, curY + 5), Vector2.new(cX + 6, curY + 5)
                        curY = curY + 20
                    else drop.ScrollDown.Visible = false end
                    drop.ListBg.Visible, drop.ListBg.Position, drop.ListBg.Size = true, Vector2.new(pos.X, pos.Y + 40), Vector2.new(mainSize.X - 40, curY - (pos.Y + 40))
                else
                    drop.ListBg.Visible, drop.ScrollUp.Visible, drop.ScrollDown.Visible = false, false, false
                    for _, d in pairs(drop.OptionDrawings) do d.Bg.Visible, d.Txt.Visible = false, false end
                end
            end
            function drop:SetVisible(vis)
                for _, s in pairs(drop.BgShapes) do s.Visible = vis end
                dTxt.Visible, dArrow.Visible = vis, vis
                if not vis or not drop.Open then
                    drop.ListBg.Visible, drop.ScrollUp.Visible, drop.ScrollDown.Visible = false, false, false
                    for _, d in pairs(drop.OptionDrawings) do d.Bg.Visible, d.Txt.Visible = false, false end
                end
            end
            table.insert(tab.Elements, drop)
            return drop
        end
        table.insert(window.Tabs, tab)
        if #window.Tabs == 1 then window.ActiveTab = tab tab.Visible = true end
        return tab
    end

    task.spawn(function()
        local sliderDragging, toggleDebounce = nil, false
        while not window.Destroyed do
            task.wait()
            if iskeypressed(0x5A) and isrbxactive() then
                if not toggleDebounce then window.Opened = not window.Opened toggleDebounce = true end
            else toggleDebounce = false end
            local vis = window.Opened
            for _, s in pairs(mainShapes) do s.Visible = vis end
            for _, s in pairs(topBarShapes) do s.Visible = vis end
            titleText.Visible, separator.Visible = vis, vis
            for _, tab in ipairs(window.Tabs) do
                tab.Btn.Visible = vis
                local active = (window.ActiveTab == tab and vis)
                for _, elem in ipairs(tab.Elements) do elem:SetVisible(active) end
            end
            if not vis then continue end
            local isPressed, mousePos = ismouse1pressed(), Vector2.new(Mouse.X, Mouse.Y)
            if window.Dragging then
                if isPressed and isrbxactive() then mainPos = window.StartPos + (mousePos - window.DragStart)
                else window.Dragging = false end
            end
            if isPressed and isrbxactive() and not wasMousePressed then
                local consumed, bDrop = false, nil
                if window.ActiveTab then for _, elem in ipairs(window.ActiveTab.Elements) do if elem.Type == "Dropdown" and elem.Open then bDrop = elem break end end end
                if bDrop then
                    if not isMouseOver(bDrop.Bg.Position, bDrop.Bg.Size) and not isMouseOver(bDrop.ListBg.Position, bDrop.ListBg.Size) then
                        bDrop.Open = false consumed = true
                    end
                end
                if not consumed then
                    if isMouseOver(mainPos, Vector2.new(mainSize.X, 40)) and not sliderDragging then
                        local clickedTab = false
                        for _, tab in ipairs(window.Tabs) do
                            if isMouseOver(tab.Btn.Position, Vector2.new(tab.Width + 5, 20)) then window.ActiveTab = tab clickedTab = true break end
                        end
                        if not clickedTab then window.Dragging, window.DragStart, window.StartPos = true, mousePos, mainPos end
                    end
                    if window.ActiveTab then
                        for _, elem in ipairs(window.ActiveTab.Elements) do
                            if bDrop and elem ~= bDrop then continue end
                            if elem.Type == "Button" and isMouseOver(elem.Border.Position, elem.Border.Size) then
                                elem.ClickTime = os.clock()
                                setShapesColor(elem.BgShapes, Color3.fromRGB(60, 60, 60))
                                task.spawn(elem.Callback)
                            elseif elem.Type == "Toggle" and isMouseOver(elem.Txt.Position - Vector2.new(30, 5), Vector2.new(200, 25)) then
                                elem.State = not elem.State
                                task.spawn(elem.Callback, elem.State)
                            elseif elem.Type == "Slider" and isMouseOver(elem.Bg.Position - Vector2.new(0, 10), elem.Bg.Size + Vector2.new(0, 20)) then
                                sliderDragging = elem
                            elseif elem.Type == "Dropdown" then
                                local cO = false
                                if elem.Open then
                                    local curY = elem.Bg.Position.Y + 40
                                    if elem.ScrollIndex > 1 then
                                        if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 20)) then elem.ScrollIndex = math.max(1, elem.ScrollIndex - 1) cO = true end
                                        curY = curY + 20
                                    end
                                    if not cO then
                                        for i = 0, elem.MaxVisible - 1 do
                                            local idx = elem.ScrollIndex + i
                                            if idx > #elem.Options then break end
                                            if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 24)) then
                                                local val = elem.Options[idx]
                                                if elem.Multi then elem.Selected[val] = not elem.Selected[val] task.spawn(elem.Callback, elem.Selected)
                                                else elem.Selected, elem.Open = val, false task.spawn(elem.Callback, elem.Selected) end
                                                cO = true break
                                            end
                                            curY = curY + 26
                                        end
                                    end
                                    if not cO and elem.ScrollIndex + elem.MaxVisible <= #elem.Options then
                                        if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 20)) then elem.ScrollIndex = math.min(#elem.Options - elem.MaxVisible + 1, elem.ScrollIndex + 1) cO = true end
                                    end
                                end
                                if not cO and isMouseOver(elem.Bg.Position, Vector2.new(elem.Bg.Size.X, 36)) then elem.Open = not elem.Open end
                            end
                        end
                    end
                end
            end
            if isPressed and sliderDragging and isrbxactive() then
                local pct = math.clamp((mousePos.X - sliderDragging.Bg.Position.X) / sliderDragging.Bg.Size.X, 0, 1)
                local newVal = math.floor(sliderDragging.Min + (sliderDragging.Max - sliderDragging.Min) * pct)
                if newVal ~= sliderDragging.Value then sliderDragging.Value = newVal sliderDragging.Val.Text = tostring(newVal) task.spawn(sliderDragging.Callback, newVal) end
            end
            if not isPressed then sliderDragging = nil end
            wasMousePressed = isPressed
            updatePositions()
        end
    end)

    function window:Destroy()
        window.Destroyed = true
        local function SafeRemove(obj)
            if obj and typeof(obj) == "table" then
                for _, sub in pairs(obj) do pcall(function() if sub and sub.Remove then sub:Remove() end end) end
            else
                pcall(function() if obj and obj.Remove then obj:Remove() end end)
            end
        end
        SafeRemove(mainShapes)
        SafeRemove(topBarShapes)
        SafeRemove(titleText)
        SafeRemove(separator)
        for _, tab in ipairs(window.Tabs) do
            SafeRemove(tab.Btn)
            for _, elem in ipairs(tab.Elements) do
                if elem.Type == "Section" then SafeRemove(elem.Txt) SafeRemove(elem.Line)
                elseif elem.Type == "Button" then SafeRemove(elem.BorderShapes) SafeRemove(elem.BgShapes) SafeRemove(elem.Txt)
                elseif elem.Type == "Toggle" then SafeRemove(elem.Outer) SafeRemove(elem.Hole) SafeRemove(elem.Inner) SafeRemove(elem.Txt)
                elseif elem.Type == "Slider" then SafeRemove(elem.Bg) SafeRemove(elem.Fill) SafeRemove(elem.Knob) SafeRemove(elem.Txt) SafeRemove(elem.Val)
                elseif elem.Type == "Dropdown" then SafeRemove(elem.BgShapes) SafeRemove(elem.Bg) SafeRemove(elem.Txt) SafeRemove(elem.Arrow) SafeRemove(elem.ScrollUp) SafeRemove(elem.ScrollDown) SafeRemove(elem.ListBg)
                    for _, d in pairs(elem.OptionDrawings) do SafeRemove(d.Bg) SafeRemove(d.Txt) end
                end
            end
        end
    end
    updatePositions()
    return window
end

function Library:ShowDemo()
    local Win = Library:CreateWindow("Demo", Vector2.new(500, 400))
    local Tab1 = Win:CreateTab("Main")
    local Tab2 = Win:CreateTab("Settings")

    Tab1:CreateSection("Features")

    Tab1:CreateButton("fat", function()
        print("Hello from Matcha!")
    end)

    Tab1:CreateToggle("Enable Feature", function(state)
        print("Feature Enabled:", state)
    end)

    Tab1:CreateSection("Configuration")

    Tab1:CreateSlider("WalkSpeed", 16, 100, function(val)
        print("Speed:", val)
    end)

    Tab1:CreateDropdown("Theme", {"Dark", "Light", "Midnight", "Ocean"}, function(val)
        print("Theme selected:", val)
    end)

    Tab2:CreateSection("Preferences")

    Tab2:CreateButton("Reset Config", function()
        print("Config Reset")
    end)

    Tab2:CreateToggle("Dark Mode", function(state)
        print("Dark Mode:", state)
    end)
end

return Library
