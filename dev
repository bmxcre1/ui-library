local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

Library = {}

function Library:CreateWindow(title, initialSize)
    local window = {}
    window.Tabs = {}
    window.ActiveTab = nil
    window.Dragging = false
    window.DragStart = Vector2.new(0, 0)
    window.StartPos = Vector2.new(0, 0)
    window.Opened = true
    window.TitleWidth = 0
    window.Destroyed = false
    
    local mainSize = initialSize or Vector2.new(550, 400)
    local mainPos = Vector2.new(100, 100)
    local cornerRadius = 6
    local colors = {
        Background = Color3.fromRGB(15, 15, 15),
        TopBar = Color3.fromRGB(25, 25, 25),
        Accent = Color3.fromRGB(65, 120, 255),
        Text = Color3.fromRGB(230, 230, 230),
        ElementBg = Color3.fromRGB(35, 35, 35),
        Border = Color3.fromRGB(10, 10, 10)
    }

    local function createRoundedBox(radius, filled)
        local shapes = {}
        shapes.TL = Drawing.new("Circle")
        shapes.TR = Drawing.new("Circle")
        shapes.BL = Drawing.new("Circle")
        shapes.BR = Drawing.new("Circle")
        shapes.R1 = Drawing.new("Square")
        shapes.R2 = Drawing.new("Square")
        for _, s in pairs(shapes) do
            if s.Type == "Circle" then
                s.Radius = radius
                s.Filled = filled
                s.NumSides = 20
            else
                s.Filled = filled
            end
            s.Visible = true
        end
        return shapes
    end

    local function createRoundedTop(radius, filled)
        local shapes = {}
        shapes.TL = Drawing.new("Circle")
        shapes.TR = Drawing.new("Circle")
        shapes.Main = Drawing.new("Square")
        shapes.Bottom = Drawing.new("Square")
        for _, s in pairs(shapes) do
            if s.Type == "Circle" then
                s.Radius = radius
                s.Filled = filled
                s.NumSides = 20
            else
                s.Filled = filled
            end
            s.Visible = true
        end
        return shapes
    end

    local mainShapes = createRoundedBox(cornerRadius, true)
    local topBarShapes = createRoundedTop(cornerRadius, true)
    
    local function setShapesColor(shapes, color)
        for _, s in pairs(shapes) do s.Color = color end
    end
    
    setShapesColor(mainShapes, colors.Background)
    setShapesColor(topBarShapes, colors.TopBar)

    local titleText = Drawing.new("Text")
    titleText.Text = title:upper()
    titleText.Size = 18
    titleText.Color = colors.Text
    titleText.Visible = true
    titleText.Font = Drawing.Fonts.System
    titleText.Center = false

    local separator = Drawing.new("Line")
    separator.Thickness = 1
    separator.Color = Color3.new(1, 1, 1)
    separator.Transparency = 0.5
    separator.Visible = true
    
    local wasMousePressed = false

    local function isMouseOver(pos, size)
        local mX, mY = Mouse.X, Mouse.Y
        return mX >= pos.X and mX <= pos.X + size.X and mY >= pos.Y and mY <= pos.Y + size.Y
    end

    local function updateRoundedBox(shapes, pos, size, radius)
        local x, y = pos.X, pos.Y
        local w, h = size.X, size.Y
        local r = radius
        shapes.TL.Position = Vector2.new(x + r, y + r)
        shapes.TR.Position = Vector2.new(x + w - r, y + r)
        shapes.BL.Position = Vector2.new(x + r, y + h - r)
        shapes.BR.Position = Vector2.new(x + w - r, y + h - r)
        shapes.R1.Position = Vector2.new(x + r, y)
        shapes.R1.Size = Vector2.new(w - 2 * r, h)
        shapes.R2.Position = Vector2.new(x, y + r)
        shapes.R2.Size = Vector2.new(w, h - 2 * r)
    end

    local function updatePositions()
        local r = cornerRadius
        local x, y = mainPos.X, mainPos.Y
        local w, h = mainSize.X, mainSize.Y
        
        updateRoundedBox(mainShapes, mainPos, mainSize, r)

        local th = 40
        topBarShapes.TL.Position = Vector2.new(x + r, y + r)
        topBarShapes.TR.Position = Vector2.new(x + w - r, y + r)
        topBarShapes.Main.Position = Vector2.new(x + r, y)
        topBarShapes.Main.Size = Vector2.new(w - 2 * r, th)
        topBarShapes.Bottom.Position = Vector2.new(x, y + r)
        topBarShapes.Bottom.Size = Vector2.new(w, th - r)
        
        titleText.Position = mainPos + Vector2.new(15, 12)
        window.TitleWidth = math.clamp(titleText.TextBounds.X, 100, 300)

        local sepX = 15 + window.TitleWidth + 10
        local sepY = mainPos.Y + 10
        separator.From = Vector2.new(mainPos.X + sepX, sepY)
        separator.To   = Vector2.new(mainPos.X + sepX, sepY + 20)

        local tabX = 15 + window.TitleWidth + 22
        for _, tab in ipairs(window.Tabs) do
            tab.Btn.Position = mainPos + Vector2.new(tabX, 12)
            tabX = tabX + tab.Width + 25
            if tab == window.ActiveTab then
                tab.Btn.Color = colors.Accent
                local currentY = mainPos.Y + 60
                for _, elem in ipairs(tab.Elements) do
                    elem:Update(Vector2.new(mainPos.X + 20, currentY))
                    currentY = currentY + elem.Height + 5
                end
            else
                tab.Btn.Color = Color3.fromRGB(150, 150, 150)
            end
        end
    end

    function window:CreateTab(name)
        local tab = {Name = name, Elements = {}, Visible = false, Width = 0}
        local tabBtn = Drawing.new("Text")
        tabBtn.Text = name
        tabBtn.Size = 16
        tabBtn.Color = Color3.fromRGB(150, 150, 150)
        tabBtn.Font = Drawing.Fonts.System
        tabBtn.Visible = true
        tab.Btn = tabBtn
        tab.Width = tabBtn.TextBounds.X
        if tab.Width == 0 then tab.Width = 50 end

        function tab:CreateSection(text)
            local sec = { Type = "Section", Height = 25 }
            local secTxt = Drawing.new("Text")
            secTxt.Text = text
            secTxt.Size = 14
            secTxt.Color = colors.Accent
            secTxt.Font = Drawing.Fonts.System
            secTxt.Visible = false
            sec.Txt = secTxt
            local secLine = Drawing.new("Square")
            secLine.Size = Vector2.new(mainSize.X - 40, 1)
            secLine.Color = colors.ElementBg
            secLine.Filled = true
            secLine.Visible = false
            sec.Line = secLine
            function sec:Update(pos)
                secTxt.Position = pos + Vector2.new(2, 0)
                secLine.Position = pos + Vector2.new(0, 18)
            end
            function sec:SetVisible(vis)
                secTxt.Visible = vis
                secLine.Visible = vis
            end
            table.insert(tab.Elements, sec)
            return sec
        end

        function tab:CreateButton(text, callback)
            local btn = { Type = "Button", Height = 32, Callback = callback, ClickTime = 0 }
            local btnRadius = 5
            local btnBorderShapes = createRoundedBox(btnRadius, true)
            setShapesColor(btnBorderShapes, colors.Border)
            local btnBgShapes = createRoundedBox(btnRadius, true)
            setShapesColor(btnBgShapes, colors.ElementBg)
            local btnTxt = Drawing.new("Text")
            btnTxt.Text = text
            btnTxt.Size = 13
            btnTxt.Color = colors.Text
            btnTxt.Font = Drawing.Fonts.System
            btnTxt.Visible = false
            btnTxt.Center = true
            btn.Txt = btnTxt
            btn.Border = { Position = Vector2.new(0,0), Size = Vector2.new(0,0) }
            btn.BorderShapes = btnBorderShapes
            btn.BgShapes = btnBgShapes
            function btn:Update(pos)
                local bSize = Vector2.new(mainSize.X - 40, 28)
                btn.Border.Position = pos
                btn.Border.Size = bSize
                updateRoundedBox(btn.BorderShapes, pos, bSize, btnRadius)
                updateRoundedBox(btn.BgShapes, pos + Vector2.new(1, 1), Vector2.new(mainSize.X - 42, 26), btnRadius)
                btnTxt.Position = pos + Vector2.new((mainSize.X - 40)/2, 13)
                if os.clock() - btn.ClickTime > 0.1 then
                    setShapesColor(btn.BgShapes, colors.ElementBg)
                end
            end
            function btn:SetVisible(vis)
                for _, s in pairs(btn.BorderShapes) do s.Visible = vis end
                for _, s in pairs(btn.BgShapes) do s.Visible = vis end
                btnTxt.Visible = vis
            end
            function btn:SetText(newText) btnTxt.Text = newText end
            table.insert(tab.Elements, btn)
            return btn
        end

        function tab:CreateToggle(text, callback)
            local tog = { Type = "Toggle", Height = 25, Callback = callback, State = false }
            local togOuter = Drawing.new("Circle")
            togOuter.Radius = 9
            togOuter.Filled = true
            togOuter.Color = colors.Accent
            togOuter.NumSides = 20
            tog.Outer = togOuter
            local togHole = Drawing.new("Circle")
            togHole.Radius = 7
            togHole.Filled = true
            togHole.Color = colors.ElementBg
            togHole.NumSides = 20
            tog.Hole = togHole
            local togInner = Drawing.new("Circle")
            togInner.Radius = 4
            togInner.Filled = true
            togInner.Color = colors.Accent
            togInner.NumSides = 20
            togInner.Visible = false
            tog.Inner = togInner
            local togTxt = Drawing.new("Text")
            togTxt.Text = text
            togTxt.Size = 14
            togTxt.Color = colors.Text
            togTxt.Font = Drawing.Fonts.System
            tog.Txt = togTxt
            function tog:Update(pos)
                local circleCenter = pos + Vector2.new(10, 12)
                togOuter.Position = circleCenter
                togHole.Position = circleCenter
                togInner.Position = circleCenter
                togTxt.Position = pos + Vector2.new(28, 4)
                togInner.Visible = (tog.State and window.Opened and window.ActiveTab == tab)
            end
            function tog:SetVisible(vis)
                togOuter.Visible = vis
                togHole.Visible = vis
                togTxt.Visible = vis
                togInner.Visible = (vis and tog.State)
            end
            table.insert(tab.Elements, tog)
            return tog
        end

        function tab:CreateSlider(text, min, max, callback)
            local sld = { Type = "Slider", Height = 40, Callback = callback, Min = min, Max = max, Value = min }
            local sBg = Drawing.new("Square")
            sBg.Size = Vector2.new(mainSize.X - 40, 4)
            sBg.Filled = true
            sBg.Color = colors.ElementBg
            sld.Bg = sBg
            local sFill = Drawing.new("Square")
            sFill.Filled = true
            sFill.Color = colors.Accent
            sld.Fill = sFill
            local sKnob = Drawing.new("Circle")
            sKnob.Radius = 6
            sKnob.Filled = true
            sKnob.Color = colors.Text
            sld.Knob = sKnob
            local sTxt = Drawing.new("Text")
            sTxt.Text = text
            sTxt.Size = 14
            sTxt.Color = colors.Text
            sTxt.Font = Drawing.Fonts.System
            sld.Txt = sTxt
            local sVal = Drawing.new("Text")
            sVal.Text = tostring(min)
            sVal.Size = 14
            sVal.Color = colors.Text
            sVal.Font = Drawing.Fonts.System
            sVal.Center = true
            sld.Val = sVal
            function sld:Update(pos)
                sTxt.Position = pos
                sVal.Position = pos + Vector2.new(mainSize.X - 50, 0)
                sBg.Position = pos + Vector2.new(0, 20)
                sFill.Position = pos + Vector2.new(0, 20)
                local pct = (sld.Value - sld.Min) / (sld.Max - sld.Min)
                sFill.Size = Vector2.new(sBg.Size.X * pct, 4)
                sKnob.Position = sFill.Position + Vector2.new(sFill.Size.X, 2)
            end
            function sld:SetVisible(vis)
                sBg.Visible, sFill.Visible, sTxt.Visible, sVal.Visible, sKnob.Visible = vis, vis, vis, vis, vis
            end
            table.insert(tab.Elements, sld)
            return sld
        end

        function tab:CreateDropdown(text, options, callback, multi)
            local drop = {Type = "Dropdown", Height = 40, Callback = callback, Options = options, Open = false, Selected = multi and {} or (options[1] or ""), Multi = multi or false, ScrollIndex = 1, MaxVisible = 6}
            local dropRadius = 5
            local dBgShapes = createRoundedBox(dropRadius, true)
            setShapesColor(dBgShapes, colors.ElementBg)
            drop.BgShapes = dBgShapes
            drop.Bg = {Position = Vector2.new(0, 0), Size = Vector2.new(mainSize.X - 40, 36)}
            local dTxt = Drawing.new("Text")
            dTxt.Size = 14
            dTxt.Color = colors.Text
            dTxt.Font = Drawing.Fonts.System
            drop.Txt = dTxt
            local dArrow = Drawing.new("Triangle")
            dArrow.Color = colors.Text
            dArrow.Filled = true
            drop.Arrow = dArrow
            local sUp = Drawing.new("Triangle")
            sUp.Color = colors.Text
            sUp.Filled, sUp.ZIndex = true, 3
            drop.ScrollUp = sUp
            local sDown = Drawing.new("Triangle")
            sDown.Color = colors.Text
            sDown.Filled, sDown.ZIndex = true, 3
            drop.ScrollDown = sDown
            local dListBg = Drawing.new("Square")
            dListBg.Filled = true
            dListBg.Color = Color3.fromRGB(28, 28, 28)
            dListBg.ZIndex = 2
            drop.ListBg = dListBg
            drop.OptionDrawings = {}
            function drop:Update(pos)
                drop.Bg.Position = pos
                updateRoundedBox(drop.BgShapes, pos, Vector2.new(mainSize.X - 40, 36), dropRadius)
                dTxt.Position = pos + Vector2.new(10, 11)
                local displayStr = ""
                if drop.Multi then
                    local count = 0
                    local first = nil
                    for k, v in pairs(drop.Selected) do if v then count = count + 1 if not first then first = k end end end
                    displayStr = count == 0 and "None" or (count == 1 and first or count .. " Selected")
                else displayStr = drop.Selected end
                dTxt.Text = text .. ": " .. displayStr
                local arrowCenter = pos + Vector2.new(mainSize.X - 60, 18)
                if drop.Open then
                    dArrow.PointA, dArrow.PointB, dArrow.PointC = arrowCenter + Vector2.new(-5, 3), arrowCenter + Vector2.new(5, 3), arrowCenter + Vector2.new(0, -3)
                else
                    dArrow.PointA, dArrow.PointB, dArrow.PointC = arrowCenter + Vector2.new(-5, -3), arrowCenter + Vector2.new(5, -3), arrowCenter + Vector2.new(0, 3)
                end
                if drop.Open then
                    local currentOptY = pos.Y + 40
                    local centerX = pos.X + (mainSize.X - 40) / 2
                    if drop.ScrollIndex > 1 then
                        drop.ScrollUp.Visible = true
                        drop.ScrollUp.PointA, drop.ScrollUp.PointB, drop.ScrollUp.PointC = Vector2.new(centerX, currentOptY + 5), Vector2.new(centerX - 6, currentOptY + 15), Vector2.new(centerX + 6, currentOptY + 15)
                        currentOptY = currentOptY + 20
                    else drop.ScrollUp.Visible = false end
                    local drawn = 0
                    for i = 0, drop.MaxVisible - 1 do
                        local idx = drop.ScrollIndex + i
                        if idx > #drop.Options then break end
                        drawn = drawn + 1
                        if not drop.OptionDrawings[drawn] then
                            local b, t = Drawing.new("Square"), Drawing.new("Text")
                            b.Color, b.Filled, b.ZIndex = Color3.fromRGB(28, 28, 28), true, 2
                            t.Color, t.Size, t.Font, t.Center, t.ZIndex = colors.Text, 13, Drawing.Fonts.System, true, 3
                            drop.OptionDrawings[drawn] = {Bg = b, Txt = t}
                        end
                        local d = drop.OptionDrawings[drawn]
                        d.Bg.Visible, d.Bg.Position, d.Bg.Size = true, Vector2.new(pos.X, currentOptY), Vector2.new(mainSize.X - 40, 24)
                        d.Txt.Visible, d.Txt.Position, d.Txt.Text = true, Vector2.new(pos.X + (mainSize.X - 40)/2, currentOptY + 12), drop.Options[idx]
                        d.Txt.Color = (drop.Multi and drop.Selected[drop.Options[idx]] or drop.Options[idx] == drop.Selected) and colors.Accent or colors.Text
                        currentOptY = currentOptY + 26
                    end
                    for i = drawn + 1, #drop.OptionDrawings do drop.OptionDrawings[i].Bg.Visible, drop.OptionDrawings[i].Txt.Visible = false, false end
                    if drop.ScrollIndex + drop.MaxVisible <= #drop.Options then
                        drop.ScrollDown.Visible = true
                        drop.ScrollDown.PointA, drop.ScrollDown.PointB, drop.ScrollDown.PointC = Vector2.new(centerX, currentOptY + 15), Vector2.new(centerX - 6, currentOptY + 5), Vector2.new(centerX + 6, currentOptY + 5)
                        currentOptY = currentOptY + 20
                    else drop.ScrollDown.Visible = false end
                    drop.ListBg.Visible, drop.ListBg.Position, drop.ListBg.Size = true, Vector2.new(pos.X, pos.Y + 40), Vector2.new(mainSize.X - 40, currentOptY - (pos.Y + 40))
                else
                    drop.ListBg.Visible, drop.ScrollUp.Visible, drop.ScrollDown.Visible = false, false, false
                    for _, d in pairs(drop.OptionDrawings) do d.Bg.Visible, d.Txt.Visible = false, false end
                end
            end
            function drop:SetVisible(vis)
                for _, s in pairs(drop.BgShapes) do s.Visible = vis end
                dTxt.Visible, dArrow.Visible = vis, vis
                if not vis or not drop.Open then
                    drop.ListBg.Visible, drop.ScrollUp.Visible, drop.ScrollDown.Visible = false, false, false
                    for _, d in pairs(drop.OptionDrawings) do d.Bg.Visible, d.Txt.Visible = false, false end
                end
            end
            table.insert(tab.Elements, drop)
            return drop
        end
        table.insert(window.Tabs, tab)
        if #window.Tabs == 1 then window.ActiveTab = tab tab.Visible = true end
        return tab
    end

    task.spawn(function()
        local sliderDragging, toggleDebounce = nil, false
        while not window.Destroyed do
            task.wait()
            if iskeypressed(0x5A) and isrbxactive() then
                if not toggleDebounce then window.Opened = not window.Opened toggleDebounce = true end
            else toggleDebounce = false end

            local vis = window.Opened
            for _, s in pairs(mainShapes) do s.Visible = vis end
            for _, s in pairs(topBarShapes) do s.Visible = vis end
            titleText.Visible, separator.Visible = vis, vis
            for _, tab in ipairs(window.Tabs) do
                tab.Btn.Visible = vis
                local active = (window.ActiveTab == tab and vis)
                for _, elem in ipairs(tab.Elements) do elem:SetVisible(active) end
            end
            if not vis then continue end

            local isPressed, mousePos = ismouse1pressed(), Vector2.new(Mouse.X, Mouse.Y)
            if window.Dragging then
                if isPressed and isrbxactive() then mainPos = window.StartPos + (mousePos - window.DragStart)
                else window.Dragging = false end
            end
            if isPressed and isrbxactive() and not wasMousePressed then
                local consumed, blockingDropdown = false, nil
                if window.ActiveTab then for _, elem in ipairs(window.ActiveTab.Elements) do if elem.Type == "Dropdown" and elem.Open then blockingDropdown = elem break end end end
                if blockingDropdown then
                    if not isMouseOver(blockingDropdown.Bg.Position, blockingDropdown.Bg.Size) and not isMouseOver(blockingDropdown.ListBg.Position, blockingDropdown.ListBg.Size) then
                        blockingDropdown.Open = false consumed = true
                    end
                end
                if not consumed then
                    if isMouseOver(mainPos, Vector2.new(mainSize.X, 40)) and not sliderDragging then
                        local clickedTab = false
                        for _, tab in ipairs(window.Tabs) do
                            if isMouseOver(tab.Btn.Position, Vector2.new(tab.Width + 5, 20)) then window.ActiveTab = tab clickedTab = true break end
                        end
                        if not clickedTab then window.Dragging, window.DragStart, window.StartPos = true, mousePos, mainPos end
                    end
                    if window.ActiveTab then
                        for _, elem in ipairs(window.ActiveTab.Elements) do
                            if blockingDropdown and elem ~= blockingDropdown then continue end
                            if elem.Type == "Button" and isMouseOver(elem.Border.Position, elem.Border.Size) then
                                elem.ClickTime = os.clock()
                                setShapesColor(elem.BgShapes, Color3.fromRGB(60, 60, 60))
                                task.spawn(elem.Callback)
                            elseif elem.Type == "Toggle" and isMouseOver(elem.Txt.Position - Vector2.new(30, 5), Vector2.new(200, 25)) then
                                elem.State = not elem.State
                                task.spawn(elem.Callback, elem.State)
                            elseif elem.Type == "Slider" and isMouseOver(elem.Bg.Position - Vector2.new(0, 10), elem.Bg.Size + Vector2.new(0, 20)) then
                                sliderDragging = elem
                            elseif elem.Type == "Dropdown" then
                                local clickedOpt = false
                                if elem.Open then
                                    local curY = elem.Bg.Position.Y + 40
                                    if elem.ScrollIndex > 1 then
                                        if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 20)) then elem.ScrollIndex = math.max(1, elem.ScrollIndex - 1) clickedOpt = true end
                                        curY = curY + 20
                                    end
                                    if not clickedOpt then
                                        for i = 0, elem.MaxVisible - 1 do
                                            local idx = elem.ScrollIndex + i
                                            if idx > #elem.Options then break end
                                            if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 24)) then
                                                local val = elem.Options[idx]
                                                if elem.Multi then elem.Selected[val] = not elem.Selected[val] task.spawn(elem.Callback, elem.Selected)
                                                else elem.Selected, elem.Open = val, false task.spawn(elem.Callback, elem.Selected) end
                                                clickedOpt = true break
                                            end
                                            curY = curY + 26
                                        end
                                    end
                                    if not clickedOpt and elem.ScrollIndex + elem.MaxVisible <= #elem.Options then
                                        if isMouseOver(Vector2.new(elem.Bg.Position.X, curY), Vector2.new(elem.Bg.Size.X, 20)) then elem.ScrollIndex = math.min(#elem.Options - elem.MaxVisible + 1, elem.ScrollIndex + 1) clickedOpt = true end
                                    end
                                end
                                if not clickedOpt and isMouseOver(elem.Bg.Position, Vector2.new(elem.Bg.Size.X, 36)) then elem.Open = not elem.Open end
                            end
                        end
                    end
                end
            end
            if isPressed and sliderDragging and isrbxactive() then
                local pct = math.clamp((mousePos.X - sliderDragging.Bg.Position.X) / sliderDragging.Bg.Size.X, 0, 1)
                local newVal = math.floor(sliderDragging.Min + (sliderDragging.Max - sliderDragging.Min) * pct)
                if newVal ~= sliderDragging.Value then sliderDragging.Value = newVal sliderDragging.Val.Text = tostring(newVal) task.spawn(sliderDragging.Callback, newVal) end
            end
            if not isPressed then sliderDragging = nil end
            wasMousePressed = isPressed
            updatePositions()
        end
    end)

    function window:Destroy()
        window.Destroyed = true
        for _, s in pairs(mainShapes) do pcall(function() s:Remove() end) end
        for _, s in pairs(topBarShapes) do pcall(function() s:Remove() end) end
        pcall(function() titleText:Remove() end)
        pcall(function() separator:Remove() end)
        for _, tab in ipairs(window.Tabs) do
            pcall(function() tab.Btn:Remove() end)
            for _, elem in ipairs(tab.Elements) do
                if elem.Type == "Section" then pcall(function() elem.Txt:Remove() end) pcall(function() elem.Line:Remove() end)
                elseif elem.Type == "Button" then for _, s in pairs(elem.BorderShapes) do pcall(function() s:Remove() end) end for _, s in pairs(elem.BgShapes) do pcall(function() s:Remove() end) end pcall(function() elem.Txt:Remove() end)
                elseif elem.Type == "Toggle" then pcall(function() elem.Outer:Remove() end) pcall(function() elem.Hole:Remove() end) pcall(function() elem.Inner:Remove() end) pcall(function() elem.Txt:Remove() end)
                elseif elem.Type == "Slider" then pcall(function() elem.Bg:Remove() end) pcall(function() elem.Fill:Remove() end) pcall(function() elem.Knob:Remove() end) pcall(function() elem.Txt:Remove() end) pcall(function() elem.Val:Remove() end)
                elseif elem.Type == "Dropdown" then pcall(function() elem.Bg:Remove() end) pcall(function() elem.Txt:Remove() end) pcall(function() elem.Arrow:Remove() end) pcall(function() elem.ScrollUp:Remove() end) pcall(function() elem.ScrollDown:Remove() end) pcall(function() elem.ListBg:Remove() end) for _, d in pairs(elem.OptionDrawings) do pcall(function() d.Bg:Remove() end) pcall(function() d.Txt:Remove() end) end
                end
            end
        end
    end
    updatePositions()
    return window
end

return Library
